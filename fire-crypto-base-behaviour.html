<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="fire-unibabel.html">

<!--
`fire-hmac-sign-behaviour`
Polymer Element fire-hmac-sign-behaviour

@demo demo/index.html 
-->


<script>
    /**
     * FiveElements Namespace definition
     */
    var FiveElements = FiveElements || {};

    /**
     * @polymerBehavior
     */
    FiveElements.FireCryptoBaseBehavior = {


        // --- Spec
        // --- ---------------------------

        /**
         * Array of all possible algo in the format : {jwk, algo}
         * https://w3c.github.io/webcrypto/Overview.html#jwk-mapping
         */
        algorithmIdentifier: [
            {
                jwk: {kty: "RSA", alg: "RS1"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-1"}}
            },
            {
                jwk: {kty: "RSA", alg: "RS256"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-256"}}
            },
            {
                jwk: {kty: "RSA", alg: "RS384"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-384"}}
            },
            {
                jwk: {kty: "RSA", alg: "RS512"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-512"}}
            },
            {
                jwk: {kty: "RSA", alg: "PS256"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-256"}}
            },
            {
                jwk: {kty: "RSA", alg: "PS384"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-384"}}
            },
            {
                jwk: {kty: "RSA", alg: "PS512"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-512"}}
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-1"}}
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-256"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-256"}}
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-384"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-384"}}
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-512"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-512"}}
            },
            {
                jwk: {kty: "EC", alg: "ES256"},
                algo: {name: "ECDSA", namedCurve: "P-256", hash: {name: "SHA-256"}}
            },
            {
                jwk: {kty: "EC", alg: "ES384"},
                algo: {name: "ECDSA", namedCurve: "P-384", hash: {name: "SHA-384"}}
            },
            {
                jwk: {kty: "EC", alg: "ES512"},
                algo: {name: "ECDSA", namedCurve: "P-521", hash: {name: "SHA-512"}}
            },
            {
                jwk: {kty: "oct", alg: "A128CTR"},
                algo: {name: "AES-CTR", length: 128}
            },
            {
                jwk: {kty: "oct", alg: "A192CTR"},
                algo: {name: "AES-CTR", length: 192}
            },
            {
                jwk: {kty: "oct", alg: "A256CTR"},
                algo: {name: "AES-CTR", length: 256}
            }, {
                jwk: {kty: "oct", alg: "A128CBC"},
                algo: {name: "AES-CBC", length: 128}
            },
            {
                jwk: {kty: "oct", alg: "A192CBC"},
                algo: {name: "AES-CBC", length: 192}
            },
            {
                jwk: {kty: "oct", alg: "A256CBC"},
                algo: {name: "AES-CBC", length: 256}
            },
            {
                jwk: {kty: "oct", alg: "A128KW"},
                algo: {name: "AES-KW", length: 128}
            },
            {
                jwk: {kty: "oct", alg: "A192KW"},
                algo: {name: "AES-KW", length: 192}
            },
            {
                jwk: {kty: "oct", alg: "A256KW"},
                algo: {name: "AES-KW", length: 256}
            },
            {
                jwk: {kty: "oct", alg: "A128GCM"},
                algo: {name: "AES-GCM", length: 128}
            },
            {
                jwk: {kty: "oct", alg: "A192GCM"},
                algo: {name: "AES-GCM", length: 192}
            },
            {
                jwk: {kty: "oct", alg: "A256GCM"},
                algo: {name: "AES-GCM", length: 256}
            },
            {
                jwk: {kty: "oct", alg: "A128GCMKW"},
                algo: {name: "AES-GCM", length: 128}
            },
            {
                jwk: {kty: "oct", alg: "A192GCMKW"},
                algo: {name: "AES-GCM", length: 192}
            },
            {
                jwk: {kty: "oct", alg: "A256GCMKW"},
                algo: {name: "AES-GCM", length: 256}
            },
            {
                jwk: {kty: "oct", alg: "HS1"},
                algo: {name: "HMAC", hash: {name: "SHA-1"}}
            },
            {
                jwk: {kty: "oct", alg: "HS256"},
                algo: {name: "HMAC", hash: {name: "SHA-256"}}
            },
            {
                jwk: {kty: "oct", alg: "HS384"},
                algo: {name: "HMAC", hash: {name: "SHA-384"}}
            },
            {
                jwk: {kty: "oct", alg: "HS512"},
                algo: {name: "HMAC", hash: "SHA-512"}
            }
        ],

        // --- Get crypto.subtle
        // --- ---------------------------
        /**
         * Get the crypto.subtle Object from the browser.
         */
        _getCryptoSubtle: function () {
            var crypto = window.crypto || window.msCrypto; //for IE11
            if (crypto.webkitSubtle) {
                return window.crypto.webkitSubtle; //for Safari
            }
            return crypto.subtle;
        },

        // --- Filter Algorythms
        // --- ---------------------------
        __filterFunctionForUsage: function (arrayOfsupportedAlgoNames) {
            return function (elt) {
                return arrayOfsupportedAlgoNames.some(function (supportedAlgoName) {
                    return supportedAlgoName === elt.algo.name;
                });
            };
        },
        _filterFunctionForSign: function () {
            return this.__filterFunctionForUsage(['HMAC', 'RSASSA-PKCS1-v1_5', 'ECDSA']);
        },
        _filterFunctionForEncrypt: function () {
            return this.__filterFunctionForUsage(['AES-CBC', 'AES-CTR', 'AES-GCM', 'RSA-OAEP']);
        },
        _filterFunctionForWrapKey: function () {
            return this.__filterFunctionForUsage(['AES-CBC', 'AES-CTR', 'AES-GCM', 'RSA-OAEP', 'AES-KW']);
        },

        // --- Algorithms Name for Usage
        // --- ---------------------------
        /**
         * Get the list of all possible Algorithm.
         */
        getAlgorithms: function (filter) {
            var list = this.algorithmIdentifier;
            if (filter) {
                list = list.filter(filter);
            }
            return list.map(function (elt) {
                return elt.algo;
            })
        },
        getAlgorithmsForSign: function () {
            return this.getAlgorithms(this._filterFunctionForSign());
        },
        getAlgorithmsForEncrypt: function () {
            return this.getAlgorithms(this._filterFunctionForEncrypt());
        },
        getAlgorithmsForWrapKey: function () {
            return this.getAlgorithms(this._filterFunctionForWrapKey());
        },
        getAlgorithmsForDigest: function () {
            return ['SHA-1', 'SHA-256', 'SHA-384', 'SHA-512'];
        },
        // --- Algorithms Names
        // --- ---------------------------
        /**
         * Get the list of all possible Algorithm.
         */
        getAlgorithmNames: function (filter) {
            var list = this.algorithmIdentifier;
            if (filter) {
                list = list.filter(filter);
            }
            return list.map(function (elt) {
                return elt.jwk.alg;
            })
        },
        getAlgorithmNamesForSign: function () {
            return this.getAlgorithmNames(this._filterFunctionForSign());
        },
        getAlgorithmNamesForEncrypt: function () {
            return this.getAlgorithmNames(this._filterFunctionForEncrypt());
        },
        getAlgorithmNamesForWrapKey: function () {
            return this.getAlgorithmNames(this._filterFunctionForWrapKey());
        },

        getAlgorithByName: function (algoName) {
            var filter = function (elt) {
                return elt.jwk.alg === algoName;
            };
            var mathAlgos =  this.getAlgorithms(filter);
            if (mathAlgos && mathAlgos.length<=1) {
                return mathAlgos[0]
            } else {
                return null;
            }

        },

        // --- Algorithms Identifier
        // --- ---------------------------
        /**
         * Filter the corresponding algo of the JSON Web Key
         */
        _filterAlgorithmIdentifierFromJwt: function (jwk) {
            var list = this.algorithmIdentifier;
            var matchAlgos = list.filter(function (elt) {
                return ((elt.jwk.alg === jwk.alg) && (elt.jwk.kty === jwk.kty));
            });
            return matchAlgos;
        },

        /**
         *  Get the corresponding algo of the JSON Web Key
         */
        getAlgoIdentifierFromJWT: function (jwk) {
            var matchAlgos = this._filterAlgorithmIdentifierFromJwt(jwk);
            var algo = undefined;
            if (matchAlgos.length > 0) {
                algo = matchAlgos[0].algo;
            }
            return algo;
        },


        getAlgorithmIdentifierFromJwtPromise: function (jwk) {
            var self = this;
            return new Promise(function (resolve, reject) {
                var matchAlgos = self._filterAlgorithmIdentifierFromJwt(jwk);
                if (!matchAlgos) {
                    reject(Error('No algorithm found for JWK ' + JSON.stringify(jwk)));
                } else if (matchAlgos.length > 1) {
                    reject(Error('Too much (' + matchAlgos.length + ') algorithm found for JWK ' + JSON.stringify(jwk)));
                } else if (matchAlgos.length === 1) {
                    var matchAlgo = matchAlgos[0].algo;
                    resolve(matchAlgo);
                }

            });
        },


        // --- Import JWK
        // --- ---------------------------
        /**
         * Wrap of https://developer.mozilla.org/fr/docs/Web/API/SubtleCrypto/importKey
         * @param jwk The JSON Web Key
         * @param extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.
         * @param usages usages is an Array of Possible values ['encrypt', 'decrypt', 'sign', 'verify', 'deriveKey', 'deriveBits', 'wrapKey', 'unwrapKey']
         * @returns result is a Promise that returns the generated CryptoKey.
         */
        importKeyJwkPromise: function (jwk, extractable, usages) {
            var self = this;
            var keyPromise = this.getAlgorithmIdentifierFromJwtPromise(jwk)
                    .then(function (algo) {
                        var cryptoSubtle = self._getCryptoSubtle();
                        return cryptoSubtle.importKey('jwk', jwk, algo, extractable, usages)
                                .then(function (key) {
                                    return {algo: algo, key: key}
                                });
                    });
            return keyPromise;
        },

        // --- Utilities
        // --- ---------------------------
        _convertDataToBuffer: function (data) {
            var datastr = JSON.stringify(data);
//            var buffer = new TextEncoder('utf-8').encode(datastr);
            var buffer = Unibabel.utf8ToBuffer(datastr);
            return buffer;
        },

        bufferToHex: function (arrayBuffer) {
            var array = new Uint8Array(arrayBuffer);
            var hexstr = Unibabel.bufferToHex(array);
            return hexstr;
        },

        /**
         * Convertion of HEX string to a ArrayBuffer*
         */
        hexToBuffer: function (hexstr) {
            var hexArray = Unibabel.hexToBuffer(hexstr);
            return hexArray;
        },


        // --- End
        // --- ---------------------------
    };

</script>