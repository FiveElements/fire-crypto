<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="fire-unibabel.html">

<!--
`fire-hmac-sign-behaviour`
Polymer Element fire-hmac-sign-behaviour

@demo demo/index.html 
-->


<script>
    /**
     * FiveElements Namespace definition
     */
    var FiveElements = FiveElements || {};

    /**
     * @polymerBehavior
     */
    FiveElements.FireCryptoBaseBehavior = {


        // --- Spec
        // --- ---------------------------

        /**
         * Array of all possible algo in the format : {jwk, algo}
         * https://w3c.github.io/webcrypto/Overview.html#jwk-mapping
         */
        algorithmIdentifier: [
            {
                jwk: {kty: "RSA", alg: "RS1"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-1"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "RS256"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-256"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "RS384"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-384"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "RS512"},
                algo: {name: "RSASSA-PKCS1-v1_5", hash: {name: "SHA-512"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "PS256"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-256"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "PS384"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-384"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "PS512"},
                algo: {name: "RSA-PSS", hash: {name: "SHA-512"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-1"}},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-256"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-256"}},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-384"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-384"}},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "RSA", alg: "RSA-OAEP-512"},
                algo: {name: "RSA-OAEP", hash: {name: "SHA-512"}},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "EC", alg: "ES256"},
                algo: {name: "ECDSA", namedCurve: "P-256", hash: {name: "SHA-256"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "EC", alg: "ES384"},
                algo: {name: "ECDSA", namedCurve: "P-384", hash: {name: "SHA-384"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "EC", alg: "ES512"},
                algo: {name: "ECDSA", namedCurve: "P-521", hash: {name: "SHA-512"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "oct", alg: "A128CTR"},
                algo: {name: "AES-CTR", length: 128},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A192CTR"},
                algo: {name: "AES-CTR", length: 192},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A256CTR"},
                algo: {name: "AES-CTR", length: 256},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            }, {
                jwk: {kty: "oct", alg: "A128CBC"},
                algo: {name: "AES-CBC", length: 128},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A192CBC"},
                algo: {name: "AES-CBC", length: 192},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A256CBC"},
                algo: {name: "AES-CBC", length: 256},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A128KW"},
                algo: {name: "AES-KW", length: 128},
                usages: ['wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A192KW"},
                algo: {name: "AES-KW", length: 192},
                usages: ['wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A256KW"},
                algo: {name: "AES-KW", length: 256},
                usages: ['wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A128GCM"},
                algo: {name: "AES-GCM", length: 128},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A192GCM"},
                algo: {name: "AES-GCM", length: 192},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A256GCM"},
                algo: {name: "AES-GCM", length: 256},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A128GCMKW"},
                algo: {name: "AES-GCM", length: 128},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A192GCMKW"},
                algo: {name: "AES-GCM", length: 192},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "A256GCMKW"},
                algo: {name: "AES-GCM", length: 256},
                usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            },
            {
                jwk: {kty: "oct", alg: "HS1"},
                algo: {name: "HMAC", hash: {name: "SHA-1"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "oct", alg: "HS256"},
                algo: {name: "HMAC", hash: {name: "SHA-256"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "oct", alg: "HS384"},
                algo: {name: "HMAC", hash: {name: "SHA-384"}},
                usages: ['sign', 'verify']
            },
            {
                jwk: {kty: "oct", alg: "HS512"},
                algo: {name: "HMAC", hash: "SHA-512"},
                usages: ['sign', 'verify']
            }
        ],

        // --- Get crypto.subtle
        // --- ---------------------------
        /**
         * Get the crypto Object from the browser.
         */
        _getCrypto: function () {
            var crypto = window.crypto || window.msCrypto; //for IE11
            return crypto;
        },

        /**
         * Get the crypto.subtle Object from the browser.
         */
        _getCryptoSubtle: function () {
            var crypto = this._getCrypto();
            if (crypto.webkitSubtle) {
                return window.crypto.webkitSubtle; //for Safari
            }
            return crypto.subtle;
        },

        // --- Filter Algorythms
        // --- ---------------------------
        __filterWithBrowserSupport: function (algoId) {
            // 192 bit AES keys are not supported in  https://www.chromium.org/blink/webcrypto
            return !((algoId.algo.length === 192) && (algoId.algo.name.slice(0, 4) === 'AES-'));
        },

        __filterFunctionForUsage: function (arrayOfsupportedAlgoNames) {
            var self = this;
            return function (algoId) {
                if (!self.__filterWithBrowserSupport(algoId)) {
                    return false;
                }
                return arrayOfsupportedAlgoNames.some(function (supportedAlgoName) {
                    return supportedAlgoName === algoId.algo.name;
                });
            };
        },


        _filterFunctionForSign: function () {
            return this.__filterFunctionForUsage(['HMAC', 'RSASSA-PKCS1-v1_5', 'ECDSA']); //   add RSA-PSS , AES-CMAC
        },
        _filterFunctionForEncrypt: function () {
            return this.__filterFunctionForUsage(['AES-CBC', 'AES-CTR', 'AES-GCM', 'RSA-OAEP']); // Add AES-CFB
        },
        _filterFunctionForWrapKey: function () {
            return this.__filterFunctionForUsage(['AES-CBC', 'AES-CTR', 'AES-GCM', 'RSA-OAEP', 'AES-KW']); // Add AES-CFB
        },
        _filterFunctionForDeriveKey: function () {
            return this.__filterFunctionForUsage(['ECDH', 'DH', 'HKDF-CTR', 'PBKDF2']); // add , 'CONCAT'
        },

        // --- Algorithms Name for Usage
        // --- ---------------------------
        /**
         * Get the list of all possible Algorithm.
         */
        getAlgorithms: function (filter) {
            var list = this.algorithmIdentifier;
            if (filter) {
                list = list.filter(filter);
            }
            return list.map(function (elt) {
                return elt.algo;
            })
        },
        getAlgorithmsForSign: function () {
            return this.getAlgorithms(this._filterFunctionForSign());
        },
        getAlgorithmsForEncrypt: function () {
            return this.getAlgorithms(this._filterFunctionForEncrypt());
        },
        getAlgorithmsForWrapKey: function () {
            return this.getAlgorithms(this._filterFunctionForWrapKey());
        },
        getAlgorithmsForDeriveKey: function () {
            return this.getAlgorithms(this._filterFunctionForDeriveKey());
        },
        getAlgorithmsForDigest: function () {
            return ['SHA-1', 'SHA-256', 'SHA-384', 'SHA-512'];
        },
        // --- Algorithms Names
        // --- ---------------------------
        /**
         * Get the list of all possible Algorithm.
         */
        getAlgorithmNames: function (filter) {
            var list = this.algorithmIdentifier;
            if (filter) {
                list = list.filter(filter);
            }
            return list.map(function (elt) {
                return elt.jwk.alg;
            })
        },
        getAlgorithmNamesForSign: function () {
            return this.getAlgorithmNames(this._filterFunctionForSign());
        },
        getAlgorithmNamesForEncrypt: function () {
            return this.getAlgorithmNames(this._filterFunctionForEncrypt());
        },
        getAlgorithmNamesForWrapKey: function () {
            return this.getAlgorithmNames(this._filterFunctionForWrapKey());
        },

        getAlgorithByName: function (algoName) {
            var filter = function (elt) {
                return elt.jwk.alg === algoName;
            };
            var mathAlgos = this.getAlgorithms(filter);
            if (mathAlgos && mathAlgos.length <= 1) {
                return mathAlgos[0]
            } else {
                return null;
            }

        },

        // --- Algorithms Identifier
        // --- ---------------------------
        /**
         * Filter the corresponding algo of the JSON Web Key
         */
        _filterAlgorithmIdentifierFromJwt: function (jwk) {
            var list = this.algorithmIdentifier;
            var matchAlgos = list.filter(function (elt) {
                if (elt.jwk.kty === jwk.kty) {
                    if (jwk.kty === 'EC') {
                        return (elt.algo.namedCurve === jwk.crv);
                    } else {
                        return (elt.jwk.alg === jwk.alg);
                    }
                }
                return false;
            });
            return matchAlgos;
        },

        /**
         *  Get the corresponding algo of the JSON Web Key
         */
        getAlgoIdentifierFromJWT: function (jwk) {
            var matchAlgos = this._filterAlgorithmIdentifierFromJwt(jwk);
            var algo = undefined;
            if (matchAlgos.length > 0) {
                algo = matchAlgos[0].algo;
            }
            return algo;
        },


        getAlgorithmIdentifierFromJwtPromise: function (jwk) {
            var self = this;
            return new Promise(function (resolve, reject) {
                var matchAlgos = self._filterAlgorithmIdentifierFromJwt(jwk);
                if (!matchAlgos) {
                    reject(Error('No algorithm found for JWK ' + JSON.stringify(jwk)));
                } else if (matchAlgos.length > 1) {
                    reject(Error('Too much (' + matchAlgos.length + ') algorithm found for JWK ' + JSON.stringify(jwk)));
                } else if (matchAlgos.length === 1) {
                    var matchAlgo = matchAlgos[0].algo;
                    resolve(matchAlgo);
                }

            });
        },


        // --- Import JWK
        // --- ---------------------------
        /**
         * Wrap of https://developer.mozilla.org/fr/docs/Web/API/SubtleCrypto/importKey
         * @param jwk The JSON Web Key
         * @param extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.
         * @param usages usages is an Array of Possible values ['encrypt', 'decrypt', 'sign', 'verify', 'deriveKey', 'deriveBits', 'wrapKey', 'unwrapKey']
         * @returns result is a Promise that returns the generated CryptoKey.
         */
        importKeyJwkPromise: function (jwk, extractable, usages) {
            var self = this;
            return this.getAlgorithmIdentifierFromJwtPromise(jwk).then(function (algo) {
                var cryptoSubtle = self._getCryptoSubtle();
                return cryptoSubtle.importKey('jwk', jwk, algo, extractable, usages).then(function (key) {
                    return {algo: algo, key: key}
                });
            });
        },

        // --- Crypto Serializer
        // --- ---------------------------
        cryptoBufferDeserialize: function (data, format, isString) {
            var datastr = isString ? data : JSON.stringify(data);
            var buffer;
            if (format === 'hex') {
                buffer = Unibabel.hexToBuffer(datastr);
            } else if (format === 'base32') {
                buffer = Unibabel.base32ToBuffer(datastr);
            } else if (format === 'base64') {
                buffer = Unibabel.base64ToBuffer(datastr);
            } else if (format === 'utf16') {
//                buffer = this._convertStr2ab(datastr);
                buffer = new TextEncoder('utf-16').encode(datastr);
            } else if (format === 'utf8') {
//                buffer = Unibabel.utf8ToBuffer(datastr);
                buffer = new TextEncoder('utf-8').encode(datastr);
            } else if (format === 'binaryString') {
                buffer = Unibabel.binaryStringToBuffer(datastr);
            } else {
                buffer = new TextEncoder(format).encode(datastr);
            }
            return buffer;
        },
        cryptoBufferSerialize: function (buffer, format, isString) {
            var str;
            if (format === 'hex') {
                str = Unibabel.bufferToHex(new Uint8Array(buffer));
            } else if (format === 'base32') {
                str = Unibabel.bufferToBase32(new Uint8Array(buffer));
            } else if (format === 'base64') {
                str = Unibabel.bufferToBase64(new Uint8Array(buffer));
            } else if (format === 'utf16') {
//                str = this._convertAb2str(buffer);
                str = new TextDecoder('utf-16').decode(new Uint16Array(buffer));
            } else if (format === 'utf8') {
//                str = Unibabel.bufferToUtf8(new Uint8Array(buffer));
                str = new TextDecoder('utf-8').decode(new Uint8Array(buffer));
            } else if (format === 'binaryString') {
                str = Unibabel.bufferToBinaryString(new Uint8Array(buffer));
            } else {
                str = new TextDecoder(format).decode(new Uint8Array(buffer));
            }
            var result = str;
            if (!isString) {
                result = JSON.parse(str);
            }
            return result;
        },


        // --- Utilities
        // --- ---------------------------
        /**
         * https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
         */
        _convertAb2str: function (buffer) {
            return String.fromCharCode.apply(null, new Uint16Array(buffer));
        },
        _convertStr2ab: function (str) {
            var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
            var bufView = new Uint16Array(buf);
            for (var i = 0, strLen = str.length; i < strLen; i++) {
                bufView[i] = str.charCodeAt(i);
            }
            return buf;
        },

        // --- End
        // --- ---------------------------
    };

</script>